import os
import pickle
import traceback
import datetime
import time
import numpy as np

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
RESULTS_DIR = os.path.join(CURRENT_DIR, "Results")

class Result:
    """
    The Result class is used to automate storing data used in a function,
    saving that data to file when the function exits (either successfully or
    due to an exception), and loading saved data from a file. This can be
    useful if it is desirable to save data that is being generated by a
    function even (or especially) when an uncaught exception is raised during
    the excecution of that function.

    To use this class effectively, initialise a Result object with `filename`
    as the filename into which data should be saved, and `data` as an object
    containing the data which will be saved (this could be a list containing
    other objects that will be modified later, for example). Use the
    `get_context` method to return a context manager that will optionally (and
    by default) save the `data` object in `filename` when this context manager
    exits (either successfully or due to an exception), and use the `load`
    method to load and return the data previously saved by an instance of this
    class.
    """
    def __init__(self, filename, data=None):
        self._data = data
        self._filename = filename

    def get_data(self):
        return self._data

    def get_context(self, save=True, suppress_exceptions=False):
        return ResultSavingContext(self, save, suppress_exceptions)

    def save(self):
        print("\nSaving results data to \"%s\"..." % self._filename)
        if not os.path.isdir(os.path.dirname(self._filename)):
            os.makedirs(os.path.dirname(self._filename))
        with open(self._filename, "wb") as f:
            pickle.dump(self._data, f)

    def load(self):
        print("Loading results data from \"%s\"..." % self._filename)
        with open(self._filename, "rb") as f:
            self._data = pickle.load(f)
        return self._data

class ResultSavingContext:
    """
    The ResultSavingContext class is used by the Result class to generate
    context managers, which optionally cause data stored inside an instance of
    the Result class to be saved to file upon exit from the context manager
    (either naturally or due to an exception), and/or to suppress exceptions
    which are raised inside the context manager, or neither.
    """
    def __init__(self, result, save, suppress_exceptions):
        self._result = result
        self._save = save
        self._suppress_exceptions = suppress_exceptions

    def __enter__(self):
        return self._result

    def __exit__(self, *args):
        if self._save:
            self._result.save()
        if self._suppress_exceptions:
            return True

class ExceptionContext:
    """
    The ExceptionContext class is designed such that instances of this class
    can used as a context manager (EG by the sweep.ParamSweeper class) to
    suppress exceptions while running experiments, and optionally print the
    details and timestamps of exceptions to the console and/or a text file.
    """
    def __init__(self, suppress_exceptions=True, printer=None):
        self._suppress_exceptions = suppress_exceptions
        if printer is None:
            printer = Printer()
        self._print = printer

    def __enter__(self):
        return

    def __exit__(self, *args):
        if args[0] is not None:
            self._print("%s: An exception occured:" % datetime.datetime.now())
            self._print("".join(traceback.format_exception(*args)))
            if self._suppress_exceptions:
                self._print("Suppressing exception and continuing...")
                return True

class Printer:
    """
    The Printer class is used to automate printing text to the console, opening
    text files, and writing to text files. An instance of the Printer class can
    be used as a callable, or by calling its `print` method (the two are
    equivalent) to print text to the console and/or a text file (or neither).
    """
    def __init__(
        self,
        output_filename=None,
        output_dir=None,
        print_to_console=True,
    ):
        """
        Initialise an instance of the Printer class, with the following
        arguments:

        - output_filename, output_dir: if output_filename is None, this
          instance of the Printer class will not write to any text files.
          Otherwise, output_filename should be a string which corresponds to a
          valid filename, and any string with which this instance is
          called/which is passed to this instance's `print` method will be
          written to a file named output_filename in the directory output_dir.
          If output_dir is None, output_dir will be set to RESULTS_DIR (default
          for both arguments is None)
        - print_to_console: if False, this instance of the Printer class will
          not print anything to the console. If True, any string with which
          this instance is called/which is passed to this instance's `print`
          method will be printed to the console (default is True)
        """
        if output_filename is not None:
            if output_dir is None:
                output_dir = RESULTS_DIR

            if not os.path.isdir(output_dir):
                os.makedirs(output_dir)

            output_path = os.path.join(output_dir, output_filename)
            self._file = open(output_path, "w")
        else:
            self._file = None

        self._print_to_console = print_to_console

    def __call__(self, s):
        self.print(s)

    def print(self, s):
        if self._print_to_console:
            print(s)
        if self._file is not None:
            print(s, file=self._file)

    def close(self):
        if self._file is not None:
            self._file.close()

class Seeder:
    """
    The Seeder class is used to repeatably generate unique random seeds and/or
    random number generators, with the following properties:

    - Any given instance of this class will never return the same seed
      twice/will never return two equivalent random number generators
    - Any two freshly initialised instances of this class will always return
      the same seed/equivalent random number generators if the
      `get_seed`/`get_rng` methods of those two instances of this class are
      called with the same arguments, even if those two instances of this class
      exist in entirely different processes
    - Any two freshly initialised instances of this class will almost surely
      return different seeds/random number generators if the
      `get_seed`/`get_rng` methods are called with different arguments
    """
    def __init__(self):
        self._used_seeds = set()

    def get_seed(self, *args):
        # Generate an integer seed corresponding to the string representation
        # of args. The output from ord (a Python built-in function that returns
        # an integer which is unique to each character) is multiplied by the
        # position of each character in the string to ensure that the seed is
        # not invariant to the order of characters in the string, encouraging
        # this expression to return different seeds for different inputs
        seed = sum((i + 1) * ord(c) for i, c in enumerate(str(args)))

        # If this seed has been returned before by this instance of Seeder,
        # then keep incrementing the seed until a new seed is generated
        while seed in self._used_seeds:
            seed += 1

        # Store and return the seed
        self._used_seeds.add(seed)
        return seed

    def get_rng(self, *args):
        seed = self.get_seed(*args)
        rng = np.random.default_rng(seed)
        return rng

def time_func(func, *args, **kwargs):
    """
    Print the running time in seconds of the function `func` when it is called
    with `*args` as arguments and `**kwargs` as keyword arguments
    """
    t_start = time.perf_counter()
    func(*args, **kwargs)
    t_total = time.perf_counter() - t_start

    print("\nFinished %r function in %.1fs" % (func.__name__, t_total))

def clean_filename(filename_str, allowed_non_alnum_chars="-_.,"):
    """
    Given a string `filename_str` which is intended to be used as a filename,
    return a copy of `filename_str` in which any character which is not
    alphanumeric or part of `allowed_non_alnum_chars` is replaced with an
    underscore. Note that `filename_str` should not contain any directory
    names, because any path separators in `filename_str` will be replaced by
    underscores
    """
    filename_str_clean = "".join(
        c if (c.isalnum() or c in allowed_non_alnum_chars) else "_"
        for c in str(filename_str)
    )
    return filename_str_clean

def is_numeric(x):
    """
    Return True if `x` is an instance of `int`, `float`, or `np.number`,
    otherwise return False. This is useful EG in the ParamSweeper.plot method,
    because the legend entry describing the optimal value of the independent
    variable is formatted differently depending on if the the independent
    variable is numeric or categorical. For more information about scalar types
    in `numpy`, see https://numpy.org/doc/stable/reference/arrays.scalars.html.
    Note that behaviour for complex or `np.nan` inputs is undefined.
    """
    return any(isinstance(x, t) for t in [int, float, np.number])
